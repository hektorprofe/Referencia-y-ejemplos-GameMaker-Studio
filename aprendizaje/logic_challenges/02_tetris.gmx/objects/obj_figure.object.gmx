<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//show_debug_message("Created");

// Determinar el tipo de forma
randomize();
f_type = irandom(6)//irandom(6);
f_angle = 0;
rotate = false;
f_grid = noone;
offset_i = 0;
offset_j = 3;
destroy = false;
figure_offset_i = 0;

switch f_type
{
    case 0:

        /// FIGURE 1  [][]
        ///           [][]
        f_grid = ds_grid_create(2,2);
        ds_grid_clear(f_grid, -1);
        f_grid[#0,0] = 1;
        f_grid[#1,0] = 1;
        f_grid[#0,1] = 1;
        f_grid[#1,1] = 1;
        break;
        
    case 1:

        /// FIGURE 2  []
        ///           [][][]
        f_grid = ds_grid_create(3,2);
        ds_grid_clear(f_grid, -1);
        f_grid[#0,0] = 7;
        f_grid[#0,1] = 7;
        f_grid[#1,1] = 7;
        f_grid[#2,1] = 7;
        figure_offset_i = 1;
        break;
        
    case 2:
    
        /// FIGURE 3      []
        ///           [][][]
        f_grid = ds_grid_create(3,2);
        ds_grid_clear(f_grid, -1);
        f_grid[#2,0] = 6;
        f_grid[#0,1] = 6;
        f_grid[#1,1] = 6;
        f_grid[#2,1] = 6;
        figure_offset_i = 1;
        break;
        
    case 3:

        /// FIGURE 4    []  
        ///           [][][]
        f_grid = ds_grid_create(3,2);
        ds_grid_clear(f_grid, -1);
        f_grid[#1,0] = 5;
        f_grid[#0,1] = 5;
        f_grid[#1,1] = 5;
        f_grid[#2,1] = 5;
        figure_offset_i = 1;
        break;
        
    case 4:

        /// FIGURE 5      
        ///           [][][][]
        f_grid = ds_grid_create(4,1);
        ds_grid_clear(f_grid, -1);
        f_grid[#0,0] = 2;
        f_grid[#1,0] = 2;
        f_grid[#2,0] = 2;
        f_grid[#3,0] = 2;
        figure_offset_i = 2;
        break;
        
    case 5:

        /// FIGURE 6    []  
        ///           [][]
        ///           []
        f_grid = ds_grid_create(2,3);
        ds_grid_clear(f_grid, -1);
        f_grid[#1,0] = 4;
        f_grid[#0,1] = 4;
        f_grid[#1,1] = 4;
        f_grid[#0,2] = 4;
        break;
        
    case 6:

        /// FIGURE 7  []  
        ///           [][]
        ///             []
        f_grid = ds_grid_create(2,3);
        ds_grid_clear(f_grid, -1);
        f_grid[#0,0] = 3;
        f_grid[#0,1] = 3;
        f_grid[#1,1] = 3;
        f_grid[#1,2] = 3;
        break;
        
}

// Iniciamos el movimiento
alarm[0] = room_speed;


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Uno hacia abajo
offset_j += 1;
alarm[0] = room_speed;
//show_debug_message("moving");
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Comprobamos el movimiento horizontal
var x_move = 0;
var h_move = true;
var r_times = 1;
rotate = false;



/// AQUI ANDO INTENTANDO ROTAR SIN SALIRME DE LOS LADOS USANDO EL OFFSET DE LA FIGURA
//offset_i = offset_i + figure_offset_i; //PERO ESTO NO VA




// Detección de movimiento horizntal contra las paredes
if keyboard_check_pressed(vk_right) 
{
    // form_position_i + spawn_point_i + min_i &lt; max_i + form_width
    if (figure_offset_i + offset_i + round(10/(ds_grid_width(f_grid))) + global.min_i &lt; global.max_i-ds_grid_width(f_grid))
    {
        //offset_i+=1;
        x_move=1;
    }
}

if keyboard_check_pressed(vk_left)
{
    // form_position_i + spawn_point_i &gt; min_i
    if (figure_offset_i + offset_i + round(10/(ds_grid_width(f_grid))) &gt; global.min_i)
    {
        //offset_i-=1;
        x_move=-1;
    }
}

// Comprobar si queremos desplazar hacia abajo el objeto
if keyboard_check_pressed(vk_down)
{
    r_times = 20;
}

// Comprobar si queremos desplazar hacia arriba el objeto
if keyboard_check_pressed(vk_up)
{
    rotate = true;
}

// Si podemos rotar lo hacemos
if (rotate)
{
    f_angle -= 1;
    if(f_angle&lt;0) f_angle = 3;
    
    // Rotamos la figura
    scr_rotate_figure();
    
    // Si hay un choque en la nueva posición rectificamos
    if scr_check_collision(figure_offset_i+offset_i,offset_j,x_move)
    {
        f_angle += 1;
        if(f_angle&gt;3) f_angle = 0;
        // Y rectificamos
        scr_rotate_figure();
    }
}


// Repeat X times
for(var k=0;k&lt;r_times;k++)
{
    /// Comprobaremos si hay bloques a los lados (si hay movimiento) o debajo
    for (var i=0;i&lt;ds_grid_width(f_grid);i++)
    {
        for (var j=0;j&lt;ds_grid_height(f_grid);j++)
        {
            
            var new_i = i + figure_offset_i + offset_i+round(10/(ds_grid_width(f_grid)))+global.min_i;
            var new_j = j + offset_j + 1; //+1 por debajo
             
            // Si en la nueva posición  horizontal hay algo
            if (global.tablero[#new_i+x_move,new_j] &gt; -1)
            {
                // Y si y solo si en esta posicion de la forma hay algo
                if (f_grid[#i,j] &gt; -1) 
                {
                    // Entonces no podemos movernos
                    h_move = false;
                }
            }
            
            // Si por debajo en el tablero hay algo
            if (global.tablero[#new_i,new_j] &gt; -1) 
            {
                // Y si y solo si en esta posicion del grid hay algo
                if (f_grid[#i,j] &gt; -1) 
                {
                    // Marcamos para destruir
                    destroy = true;
                }
            }
        }
    }
    
    // Si podemos movernos horizontalmente lo hacemo
    if(h_move) offset_i+=x_move;
    
    // Si hay colision dibujaremos la forma en el tablero y la borraremos
    if (destroy)
    {
        for (var i=0;i&lt;ds_grid_width(f_grid);i++)
        {
            for (var j=0;j&lt;ds_grid_height(f_grid);j++)
            {
                //show_debug_message("CONTADOR");
        
                var new_i = i + figure_offset_i + offset_i+round(10/(ds_grid_width(f_grid)))+global.min_i;
                var new_j = j + offset_j;
                
                //show_debug_message("Check if destroy:" + string(f_grid[#i,j] &gt; -1));
                if (f_grid[#i,j] &gt; -1) 
                {
                    global.tablero[#new_i,new_j] = f_grid[#i,j];
                    destroy = true;
                    r_times = 0; // Aunque luego rompamos la instancia se acaban de repetir, por eso hay que sacaros ya
                }
            }
        }
        
        // Si no nos hemos movido
        if(offset_j==3) game_restart();
        
        global.new_form = true;
        instance_destroy();
    }
    
    if (r_times&gt;1) offset_j+=1;
    
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw the grid
for (var i=0;i&lt;ds_grid_width(f_grid);i++)
{
    for (var j=0;j&lt;ds_grid_height(f_grid);j++)
    {
    
        var new_i = i + figure_offset_i + offset_i+round(10/(ds_grid_width(f_grid)))+global.min_i;
        var new_j = j + offset_j;
        
        if (f_grid[#i,j] &gt; -1) 
        {
            draw_sprite(spr_block,f_grid[#i,j],32*new_i+16,32*new_j+16);
        }
        //show_debug_message("END");
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
